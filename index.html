<html>
<head>
  <link rel="stylesheet" href="css/tufte.css"/>
  <style>
@media all {
.nav {
  display: none;
}
}

@media screen and (min-width: 1279px) {
.nav {
  display: block;
  position: fixed;
  top: 40%;
  left: 0;
}

.nav li {
/*  list-style-type: none;*/
}
}

  </style>
  <title>pcd - Pancake Crop Deli</title>
</head>
<body>

<ul class="nav">
  <li><a href="#top">PCD</a></li>
  <li><a href="#why">Why</a></li>
  <li><a href="#architecture">Architecture</a></li>
  <li><a href="#goals">Goals</a></li>
  <li><a href="#design">Design</a></li>
  <li><a href="#using">Using</a></li>
</ul>

<article><h1>Pancake Crop Deli</h1>

<p class="subtitle">How Appliances Should Be</p>

<section>

<p>PCD is a distribution of Linux designed to run containers in Docker in the
most secure way possible. PCD only defines opinions about the container runtime
and the fewest possible supporting components.</p>

</section>

<section><h2 id="why">Why</h2>

<p>After learning about CoreOS, and then Rancher, I had different opinions
about what is needed to support Docker containers. I didn't want to be tied to
the opinions of any other minimal container operating system.

</section>

<section><h2 id="architecture">Architecture</h2>

<p>The base system is build to run entirely from RAM. The drives in the system
are only persistent data from containers and booting.

<p>The first partition on the system is 200MB. This partition is marked
bootable and has the grub bootloader installed. This should leave room for a
primary and backup kernel and allow future room for expansion.

<p>The second partition is used for Docker images, containers, and any shared
directories. This partition is automatically expanded at boot if needed.

</section>

<section><h2 id="goals">Goals</h2>
<p><b>Cloud provider and hardware agnostic.</b>
No dependencies on anything provided by a particular vendor, cloud or hardware.

<p><b>Easy upgrades.</b>
Currently, this is simply running the installer again.

<p><b>Minimal components to run Docker.</b>
Only the absolute necessary components are used. There is no
<a href="https://blog.qualys.com/laws-of-vulnerabilities/2015/01/27/the-ghost-vulnerability">glibc</a>,
<a href="http://heartbleed.com/">openssl</a>,
<a href="http://seclists.org/oss-sec/2014/q3/650">bash</a>, or
<a href="http://arstechnica.com/security/2015/07/bug-in-widely-used-openssh-opens-servers-to-password-cracking/">openssh</a>.
In fact, the only SSL implementation used is the implementation from Go in
the Docker Engine itself.

</section>

<section><h2 id="design">Design Decisions</h2>
<p>The common use case is as a turn-key docker-engine. There's a number of design
features that are different than traditional GNU/Linux systems that could be
confusing to people that aren't expecting them.

<h3>No /usr or /sbin</h3>

<p>There's no /usr directory. With the understanding that the /usr directory is for utilities and services that aren't essential to the booting of the system, and the understanding that the system is successful only when it's running the Docker Engine, there's just not a need for /usr anymore. Also, in the same vein, if the system only runs a few services, all as the root user, and humans aren't even suppose to obtain login shells to the system, there's no difference remaining between /sbin and /bin. Therefore, there's no /sbin either.

More here: TODO

<h3>No dynamic binaries</h3>

<p>Dynamic binaries do a great job of only depending on a common interface, an ABI, with the libraries they use. This is great when a system is upgraded over time, a library here, a library there. When the system is meant to be upgraded as a whole, this benefit goes unrealized. When the libraries aren't upgraded separate from the binaries that use them, they just take up extra bloat, with extra functions and features uncalled. Compiling binaries statically only imports the needed functions from libraries, leaving dead code behind.

<h3>Busybox</h3>

<p>In order to stay as light weight as possible, and without the requirement of abstract flexibility, busybox was chosen to fill the role of coreutils, init system, and logging. There's only a few services on the system where busybox isn't used.
</section>

<section><h2 id="using">Using</h2>

<h3>ISO</h3>

<p>Perhaps the easiest usage is with the official ISO distribution. Simply boot
this and run.

<h3>Kernel</h3>

<p>The more versatile distribution is the raw kernel image with included
initramfs. This is the only file needed for PXE booting.

<h3>Vagrant box</h3>

<p>There is a
<a href="https://github.com/brimstone/pcd/blob/master/Vagrantfile">
Vagrantfile</a> included with the source project that can be used as-is, or as
a base for other vagrant projects.

</section>

</article>

<script src="/livereload.js"></script>
</body>
</html>
